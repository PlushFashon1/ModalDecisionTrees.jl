# https://nbviewer.jupyter.org/github/sisl/ExprRules.jl/blob/master/examples/grammar.ipynb

# @inline f_getattr(, ::Val(N)) where N =
@inline f_getattr(channel, N) = channel[N]

grammar = @grammar begin
	p = min, (≥)
	p = max, (≤)
	p = f, bowtie
	f = cos | sin
	f = f_getattr, Integer # TODO solve this with integers...
	# f = (channel)->f_getattr(channel, Integer) ... 
#  f = _(f_getattr ...)
	bowtie = (≤) | (≥)
end

# ExpressionIterator(grammar, typemax(BigInt), :p) |> collect .|> (rulenode)->display(rulenode, grammar)

rulenodes = ExpressionIterator(grammar, 10, :p) |> collect
for rulenode in rulenodes
	display(rulenode, grammar)

end








def pareto_front(population):
		f = MoFitness()
		pf = set()
		for individual in population:
				if all(not is_dominated(f(individual), f(i)) for i in pf):  #  and f(individual) != f(i) 
						# Adding individual
						new_pf = {individual}
						for i in pf:
								if not is_dominated(f(i), f(individual)):
										new_pf.add(i)
						pf = new_pf
		return pf

def levelize(population):
		levels = list()
		population = set(population)
		while population:
				pf = pareto_front(population)
				levels.append(pf)
				population -= pf
		return levels

def rank(population):
		levels = levelize(population)
		ranking = dict()
		for individual in population:
				for l, i in enumerate(levels):
						if individual in i:
								ranking[individual] = l
		return ranking